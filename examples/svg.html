<html lang=en>
  <head>
    <meta charset="UTF-8">
    <script src="../numeric-1.2.6.js"></script>
    <script src="../constrain.js"></script>
    <script src="../canvas2svg.js"></script>
    <script src="../constrain-ps.js"></script>
    <script src="../constrain-pdf.js"></script>
    <script src="../constrain-mathjax.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.5/es5/tex-mml-svg.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.js"></script>
    <style>
      body {
        font-family: sans-serif
      }

      h1 {
        text-align: center
      }

      p {
        text-justify: interword;
        text-align: justify;
        line-height: 1.5em
      }

      #content {
        margin: 0 auto;
        max-width: 80ex
      }
    </style>
  </head>
  <body>
    <h1>Rendering to SVG</h1>
    <div id=content>
      <div style="display: block">
        <canvas id="canvas" style="width: 700px; height: 400px"></canvas>
      </div>
      <p>Below we have an SVG that embeds math as a foreign object. Right now, it seems that constrain relies on the canvas being displayed in the dom, so I have to do some stupid hack to get rid of it after the SVG is rendered. Hopefully that could be cleaned up. </p>
      <div id="svg"></div>
      <script>
        const canvas = document.getElementsByTagName("canvas")[0]
        const figure = new Constrain.Figure(canvas)
        with(figure) {
          const s1 = square().setLineWidth(3),
            s2 = square().setLineWidth(3)
          align("abut", "top", s1, hspace(40), s2)
          equal(s1.w(), 300, s2.w())
          equal(s1.x1(), canvasRect().x())
          align("left", "center", s1, canvasRect().inset(2))
          const h1 = horzLine(),
            v1 = vertLine()
          const a = minus(v1.x(), s1.x0()),
            b = minus(s1.x1(), v1.x())
          equal(a, minus(h1.y(), s1.y0()))
          align("left right", "none", h1, s1)
          align("none", "top bottom", v1, s1)
          equal(minus(h1.y(), s1.y0()), a)
          // align("none", "center", h1, hand)
          const asq = square().setFillStyle("#eaa")
          mathJax("a^2").at(asq.center())
          const bsq = square().setFillStyle("#aea")
          mathJax("b^2").at(bsq.center())
          align("left", "top", asq, s1)
          align("right", "none", asq, v1)
          align("right", "bottom", bsq, s1)
          align("left", "none", bsq, v1)

          function rt(p1, p2, p3) {
            return figure.polygon([p1, p2, p3]).setFillStyle("#eea")
          }
          rt(s1.ll(), asq.ll(), bsq.ll())
          rt(bsq.ll(), asq.ll(), asq.lr())
          rt(asq.ur(), s1.ur(), bsq.ur())
          rt(asq.ur(), asq.lr(), bsq.ur())
          const p1 = s2.ll().toRight(a),
            p2 = s2.ul().toBottom(a),
            p3 = s2.ur().toLeft(a),
            p4 = s2.lr().toTop(a),
            poly = polygon([p1, p2, p3, p4]).setFillStyle("#ccf")
          mathJax("c^2").at(poly.center())
          rt(p1, p2, s2.ll())
          rt(p2, p3, s2.ul())
          rt(p3, p4, s2.ur())
          rt(p4, p1, s2.lr())
          setStrokeStyle("#008")
          const al1 = mathJax("a").at(average(s1.ll(), bsq.ll()).toBottom(10))
          connector(al1.toLeft(5), point(s1.x0(), al1.y())).setEndArrow("arrow")
          connector(al1.toRight(5), point(bsq.x0(), al1.y())).setEndArrow("arrow")
          const al2 = mathJax("a").at(s2.ll().toRight(times(a, 0.5)).toBottom(10))
          connector(al2.toLeft(5), point(s2.x0(), al2.y())).setEndArrow("arrow")
          connector(al2.toRight(5), p1.toBottom(10)).setEndArrow("arrow")
          const bl1 = mathJax("b").at(average(s1.ll(), asq.ll()).toLeft(10))
          connector(bl1.toTop(5), asq.ll().toLeft(10)).setEndArrow("arrow")
          connector(bl1.toBottom(5), s1.ll().toLeft(10)).setEndArrow("arrow")
          const bl2 = mathJax("b").at(average(s2.ll(), p2).toLeft(10))
          const bl2t = point(bl2.x(), p2.y()),
            bl2b = point(bl2.x(), p1.y())
          connector(bl2.toTop(5), bl2t).setEndArrow("arrow")
          connector(bl2.toBottom(5), bl2b).setEndArrow("arrow")
          let nx = variable("nx", 5),
            ny = variable("ny", 5)
          equal(times(nx, b), times(ny, a))
          equal(plus(sq(nx), sq(ny)), 121)
          const cl1 = mathJax("c").at(average(asq.ll(), bsq.ll()).toRight(ny).toTop(nx))
          const cl2 = mathJax("c")
          equal(cl1.y(), cl2.y())
          equal(minus(cl2.x(), s2.x0()), minus(cl1.x(), s1.x0()))
          connector(cl1.center().toLeft(nx).toTop(ny), asq.ll().toRight(ny).toTop(nx)).setEndArrow("arrow")
          connector(cl1.center().toRight(nx).toBottom(ny), bsq.ll().toRight(ny).toTop(nx)).setEndArrow("arrow")
          connector(cl2.center().toLeft(nx).toTop(ny), p2.toRight(ny).toTop(nx)).setEndArrow("arrow")
          connector(cl2.center().toRight(nx).toBottom(ny), p1.toRight(ny).toTop(nx)).setEndArrow("arrow")
          figure.ctx = new C2S(700, 400);
          figure.render();
          var mysvg = ctx.getSvg();
          document.getElementById("svg").appendChild(mysvg);
          canvas.remove();
        }
      </script>
    </div>
  </body>
</html>
